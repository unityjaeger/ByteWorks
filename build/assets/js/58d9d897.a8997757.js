"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[217],{8392:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>d,contentTitle:()=>l,default:()=>o,frontMatter:()=>a,metadata:()=>n,toc:()=>c});const n=JSON.parse('{"id":"how","title":"Types","description":"Compared to other existing Ser/Des modules (like Squash), ByteWorks does not use dynamically resized buffers. Each type has a size method that calculates the exact buffer size needed to hold the serialized data, with some types having a static size, while still being a method so everything is consistent.","source":"@site/docs/how.md","sourceDirName":".","slug":"/how","permalink":"/ByteWorks/docs/how","draft":false,"unlisted":false,"editUrl":"https://github.com/unityjaeger/ByteWorks/edit/main/docs/how.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"defaultSidebar","previous":{"title":"Examples","permalink":"/ByteWorks/docs/examples"},"next":{"title":"Advanced Examples","permalink":"/ByteWorks/docs/advanced_examples"}}');var s=t(4848),i=t(8453);const a={sidebar_position:3},l="Types",d={},c=[{value:"Numbers",id:"numbers",level:2},{value:"Unsigned Integers",id:"unsigned-integers",level:3},{value:"Signed Integers",id:"signed-integers",level:3},{value:"Floating Point Numbers",id:"floating-point-numbers",level:3},{value:"Variable Length Quantity",id:"variable-length-quantity",level:3},{value:"Signed Variable Length Quantity",id:"signed-variable-length-quantity",level:3},{value:"Booleans",id:"booleans",level:2},{value:"Buffers",id:"buffers",level:2},{value:"CFrame",id:"cframe",level:2},{value:"Arrays",id:"arrays",level:2},{value:"Dynamic Arrays",id:"dynamic-arrays",level:3},{value:"Fixed Size Arrays",id:"fixed-size-arrays",level:3},{value:"Maps",id:"maps",level:2},{value:"Struct",id:"struct",level:2},{value:"Regular Structs",id:"regular-structs",level:3},{value:"Optional Structs",id:"optional-structs",level:3},{value:"Literal",id:"literal",level:2},{value:"Enum",id:"enum",level:2},{value:"Bitfield",id:"bitfield",level:2},{value:"Bitmask",id:"bitmask",level:2}];function h(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"types",children:"Types"})}),"\n",(0,s.jsx)(r.p,{children:"Compared to other existing Ser/Des modules (like Squash), ByteWorks does not use dynamically resized buffers. Each type has a size method that calculates the exact buffer size needed to hold the serialized data, with some types having a static size, while still being a method so everything is consistent."}),"\n",(0,s.jsx)(r.p,{children:"This changes how you serialize multiple types sequentially slightly, instead of just being able to push them to the dynamic buffer, you have to create a buffer with the right size before performing any serialization."}),"\n",(0,s.jsx)(r.p,{children:"The huge benefit of this approach is performance. If you use a dynamic approach not only do you need to create a new buffer each time a resize happens, you also have to copy the previous contents to the new buffer. Then, once you're done serializing all your data, you have to create another buffer with the actual needed size for the serialized data and then copy the contents to the new buffer."}),"\n",(0,s.jsx)(r.h2,{id:"numbers",children:"Numbers"}),"\n",(0,s.jsxs)(r.p,{children:["Numbers in luau are stored as 8 byte double precision floating point numbers. If we want to represent integers, then the representable range is ",(0,s.jsx)(r.strong,{children:"\u22122\u2075\xb3 to 2\u2075\xb3"}),"."]}),"\n",(0,s.jsx)(r.h3,{id:"unsigned-integers",children:"Unsigned Integers"}),"\n",(0,s.jsx)(r.p,{children:"Unsigned integers refer to whole numbers. The available types with their respective ranges are:"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Type"}),(0,s.jsx)(r.th,{children:"Bytes"}),(0,s.jsx)(r.th,{children:"Min"}),(0,s.jsx)(r.th,{children:"Max"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"u8"}),(0,s.jsx)(r.td,{children:"1"}),(0,s.jsx)(r.td,{children:"0"}),(0,s.jsx)(r.td,{children:"255"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"u16"}),(0,s.jsx)(r.td,{children:"2"}),(0,s.jsx)(r.td,{children:"0"}),(0,s.jsx)(r.td,{children:"65,535"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"u24"}),(0,s.jsx)(r.td,{children:"3"}),(0,s.jsx)(r.td,{children:"0"}),(0,s.jsx)(r.td,{children:"16,777,215"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"u32"}),(0,s.jsx)(r.td,{children:"4"}),(0,s.jsx)(r.td,{children:"0"}),(0,s.jsx)(r.td,{children:"4,294,967,295"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"u53"}),(0,s.jsx)(r.td,{children:"7"}),(0,s.jsx)(r.td,{children:"0"}),(0,s.jsx)(r.td,{children:"9,007,199,254,740,992"})]})]})]}),"\n",(0,s.jsx)(r.h3,{id:"signed-integers",children:"Signed Integers"}),"\n",(0,s.jsx)(r.p,{children:"Signed Integers refer to integers as they are commonly known in math. They have a sign bit as their first bit to dictate whether the number is a positive number or a negative number. The available types with their respective ranges are:"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Type"}),(0,s.jsx)(r.th,{children:"Bytes"}),(0,s.jsx)(r.th,{children:"Min"}),(0,s.jsx)(r.th,{children:"Max"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"i8"}),(0,s.jsx)(r.td,{children:"1"}),(0,s.jsx)(r.td,{children:"-128"}),(0,s.jsx)(r.td,{children:"127"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"i16"}),(0,s.jsx)(r.td,{children:"2"}),(0,s.jsx)(r.td,{children:"-32,768"}),(0,s.jsx)(r.td,{children:"32,767"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"i24"}),(0,s.jsx)(r.td,{children:"3"}),(0,s.jsx)(r.td,{children:"-8,388,608"}),(0,s.jsx)(r.td,{children:"8,388,607"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"i32"}),(0,s.jsx)(r.td,{children:"4"}),(0,s.jsx)(r.td,{children:"-2,147,483,648"}),(0,s.jsx)(r.td,{children:"2,147,483,647"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"i53"}),(0,s.jsx)(r.td,{children:"7"}),(0,s.jsx)(r.td,{children:"-9,007,199,254,740,992"}),(0,s.jsx)(r.td,{children:"9,007,199,254,740,992"})]})]})]}),"\n",(0,s.jsx)(r.p,{children:"You are able to store up to 56 bit integers theoretically with i53, but past the specified ranges integers are not exactly representable anymore, since they round to a multiple higher than 1."}),"\n",(0,s.jsx)(r.h3,{id:"floating-point-numbers",children:"Floating Point Numbers"}),"\n",(0,s.jsx)(r.p,{children:"Floating point numbers are commonly known as decimal numbers, the available types are:"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Type"}),(0,s.jsx)(r.th,{children:"Bytes"}),(0,s.jsx)(r.th,{children:"Min"}),(0,s.jsx)(r.th,{children:"Max"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"f16"}),(0,s.jsx)(r.td,{children:"2"}),(0,s.jsx)(r.td,{children:"-65,504"}),(0,s.jsx)(r.td,{children:"65,504"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"f32"}),(0,s.jsx)(r.td,{children:"4"}),(0,s.jsx)(r.td,{children:"ca. -10^38"}),(0,s.jsx)(r.td,{children:"ca. 10^38"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"f64"}),(0,s.jsx)(r.td,{children:"8"}),(0,s.jsx)(r.td,{children:"ca. -10^308"}),(0,s.jsx)(r.td,{children:"ca 10^308"})]})]})]}),"\n",(0,s.jsx)(r.p,{children:"It is very important to note that floating point numbers behave differently from integers, with floating point numbers, the higher the number is, the lower the precision. Let me demonstrate this with f16:"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Min"}),(0,s.jsx)(r.th,{children:"Max"}),(0,s.jsx)(r.th,{children:"Interval"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"128"}),(0,s.jsx)(r.td,{children:"256"}),(0,s.jsx)(r.td,{children:"0.125"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"256"}),(0,s.jsx)(r.td,{children:"512"}),(0,s.jsx)(r.td,{children:"0.25"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"512"}),(0,s.jsx)(r.td,{children:"1024"}),(0,s.jsx)(r.td,{children:"0.5"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"1024"}),(0,s.jsx)(r.td,{children:"2048"}),(0,s.jsx)(r.td,{children:"1"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"2048"}),(0,s.jsx)(r.td,{children:"4096"}),(0,s.jsx)(r.td,{children:"2"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"4096"}),(0,s.jsx)(r.td,{children:"8192"}),(0,s.jsx)(r.td,{children:"4"})]})]})]}),"\n",(0,s.jsx)(r.p,{children:"Naturally, f32 and f64 have way better precision with low numbers like these, but this is something you have to keep in mind when using floating point numbers, especially when you're using f16."}),"\n",(0,s.jsx)(r.h3,{id:"variable-length-quantity",children:"Variable Length Quantity"}),"\n",(0,s.jsx)(r.p,{children:"Variable length quantity numbers are useful when you don't know how many bytes a number needs, or when you encode a diverse set of numbers and you don't want to opt for the largest type needed to accomodate every possible number you will serialize. VLQs store the number in the first 7 bits and the last bit is the \"continuation bit\", which basically tells the algorithm if there is more to the number and if it should continue reading/writing. This means that VLQs are less efficient if you have numbers in similar ranges, as each block of 8 bits needs a continuation bit."}),"\n",(0,s.jsx)(r.p,{children:"Here are some example ranges for different byte counts:"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Bytes"}),(0,s.jsx)(r.th,{children:"Min"}),(0,s.jsx)(r.th,{children:"Max"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"1"}),(0,s.jsx)(r.td,{children:"0"}),(0,s.jsx)(r.td,{children:"127"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"2"}),(0,s.jsx)(r.td,{children:"0"}),(0,s.jsx)(r.td,{children:"16,383"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"3"}),(0,s.jsx)(r.td,{children:"0"}),(0,s.jsx)(r.td,{children:"2,097,151"})]})]})]}),"\n",(0,s.jsx)(r.h3,{id:"signed-variable-length-quantity",children:"Signed Variable Length Quantity"}),"\n",(0,s.jsx)(r.p,{children:"Here are some example ranges for different byte counts:"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Bytes"}),(0,s.jsx)(r.th,{children:"Min"}),(0,s.jsx)(r.th,{children:"Max"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"1"}),(0,s.jsx)(r.td,{children:"-63"}),(0,s.jsx)(r.td,{children:"63"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"2"}),(0,s.jsx)(r.td,{children:"-8,191"}),(0,s.jsx)(r.td,{children:"8,191"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"3"}),(0,s.jsx)(r.td,{children:"-1,048,575"}),(0,s.jsx)(r.td,{children:"1,048,575"})]})]})]}),"\n",(0,s.jsx)(r.h2,{id:"booleans",children:"Booleans"}),"\n",(0,s.jsx)(r.p,{children:"We only need 1 bit to determine if a boolean is true (1) or false (0), however buffers work in bytes, so we can combine 8 booleans into 1 byte to make the most of our space."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"local boolean = ByteWorks.boolean\r\nlocal buff = buffer.create(boolean.size())\r\nboolean.ser(buff, 0, true, true, false, false, true, false, true, false)\r\n--we use select because the first returned value is the offset after the deserialization, and we dont need that\r\nprint(select(2, boolean.des(buff, 0))) --\x3e true true false false true false true false\n"})}),"\n",(0,s.jsx)(r.h2,{id:"buffers",children:"Buffers"}),"\n",(0,s.jsx)(r.p,{children:"Buffers can be written into buffers, which is just a copy operation, this is useful if you only want to serialize data when it changes instead of every time it is replicated for example."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"local bufferType = ByteWorks.buffer\r\nlocal sourceBuff = buffer.create(4)\r\nbuffer.writeu32(sourceBuff, 0, 123456) --write some data into the source buffer\r\n\r\nlocal destBuff = buffer.create(bufferType.size(sourceBuff))\r\nbufferType.ser(destBuff, 0, sourceBuff)\r\n\r\nlocal _, deserializedBuff = bufferType.des(destBuff, 0)\r\nprint(buffer.readu32(deserializedBuff, 0)) --\x3e 123456\n"})}),"\n",(0,s.jsx)(r.h2,{id:"cframe",children:"CFrame"}),"\n",(0,s.jsx)(r.p,{children:"Simple implementation of CFrame serialization and deserialization, it is very general purpose and I reccomend making your own serializer for CFrames that is better suited to your needs."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"local cframeType = ByteWorks.cframe\r\nlocal cframe = CFrame.new(10, 20, 30) * CFrame.fromOrientation(math.pi / 4, math.pi / 2, 0)\r\n\r\nlocal buff = buffer.create(cframeType.size(cframe))\r\ncframeType.ser(buff, 0, cframe)\r\n\r\nlocal _, deserializedCFrame = cframeType.des(buff, 0)\r\nprint(deserializedCFrame.Position, deserializedCFrame:ToOrientation()) --\x3e 10, 20, 30, pi/4, pi/2, 0\n"})}),"\n",(0,s.jsx)(r.h2,{id:"arrays",children:"Arrays"}),"\n",(0,s.jsx)(r.p,{children:"There are both dynamic arrays and fixed size arrays, arrays can only work with one type."}),"\n",(0,s.jsx)(r.h3,{id:"dynamic-arrays",children:"Dynamic Arrays"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:'local arrayType = ByteWorks.array(ByteWorks.u8)\r\nlocal data = {1, 2, 3, 4, 5}\r\n\r\nlocal buff = buffer.create(arrayType.size(data))\r\narrayType.ser(buff, 0, data)\r\n\r\nlocal _, deserializedData = arrayType.des(buff, 0)\r\nprint(table.concat(deserializedData, ", ")) --\x3e 1, 2, 3, 4, 5\n'})}),"\n",(0,s.jsx)(r.h3,{id:"fixed-size-arrays",children:"Fixed Size Arrays"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:'local fixedArrayType = ByteWorks.fixedSizeArray(ByteWorks.u8, 3)\r\nlocal data = {10, 20, 30}\r\n\r\nlocal buff = buffer.create(fixedArrayType.size(data))\r\nfixedArrayType.ser(buff, 0, data)\r\n\r\nlocal _, deserializedData = fixedArrayType.des(buff, 0)\r\nprint(table.concat(deserializedData, ", ")) --\x3e 10, 20, 30\n'})}),"\n",(0,s.jsx)(r.h2,{id:"maps",children:"Maps"}),"\n",(0,s.jsx)(r.p,{children:"Maps are tables that associate keys with values. While the value type can be anything, the key type must be indexable (e.g., numbers, strings)."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"local mapType = ByteWorks.map(ByteWorks.string, ByteWorks.u8)\r\nlocal data = {apple = 1, banana = 2, cherry = 3}\r\n\r\nlocal buff = buffer.create(mapType.size(data))\r\nmapType.ser(buff, 0, data)\r\n\r\nlocal _, deserializedData = mapType.des(buff, 0)\r\nprint(deserializedData) --\x3e {apple = 1, banana = 2, cherry = 3}\n"})}),"\n",(0,s.jsx)(r.h2,{id:"struct",children:"Struct"}),"\n",(0,s.jsx)(r.p,{children:"Structs map a string identifier to a specific value type, since the identifiers are known ahead of time, we don't have to serialize them."}),"\n",(0,s.jsx)(r.h3,{id:"regular-structs",children:"Regular Structs"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:'local structType = ByteWorks.struct({\r\n    name = ByteWorks.string,\r\n    age = ByteWorks.u8,\r\n    isAdmin = ByteWorks.boolean,\r\n})\r\n\r\nlocal data = {name = "Alice", age = 25, isAdmin = true}\r\n\r\nlocal buff = buffer.create(structType.size(data))\r\nstructType.ser(buff, 0, data)\r\n\r\nlocal _, deserializedData = structType.des(buff, 0)\r\nprint(deserializedData) --\x3e {name = "Alice", age = 25, isAdmin = true}\n'})}),"\n",(0,s.jsx)(r.h3,{id:"optional-structs",children:"Optional Structs"}),"\n",(0,s.jsx)(r.p,{children:"Structs also support optional fields, the cost for an optional field is only 1 byte per 8 optionals. They are a seperate type due to performance implications."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:'local optStructType = ByteWorks.optStruct({\r\n\tname = ByteWorks.string,\r\n\tage = ByteWorks.opt(ByteWorks.u8),\r\n})\r\n\r\nlocal data = {name = "John", age = nil}\r\n\r\nlocal buff = buffer.create(optStructType.size(data))\r\noptStructType.ser(buff, 0, data)\r\n\r\nlocal _, deserializedData = optStructType.des(buff, 0)\r\nprint(deserializedData) --\x3e {name = "John"}\n'})}),"\n",(0,s.jsx)(r.h2,{id:"literal",children:"Literal"}),"\n",(0,s.jsx)(r.p,{children:"Literals are values that can be stored with just an u8, which is useful for things like unique identifiers."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:'local literalType = ByteWorks.literal("apple", "banana", "cherry")\r\nlocal value = "banana"\r\n\r\nlocal buff = buffer.create(literalType.size(value))\r\nliteralType.ser(buff, 0, value)\r\n\r\nlocal _, deserializedValue = literalType.des(buff, 0)\r\nprint(deserializedValue) --\x3e banana\n'})}),"\n",(0,s.jsx)(r.h2,{id:"enum",children:"Enum"}),"\n",(0,s.jsx)(r.p,{children:"Enums store a roblox Enum either as an u8 or an u16, depending on the highest enum value present within that enum."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"local enumType = ByteWorks.enum(Enum.Material)\r\nlocal value = Enum.Material.Concrete\r\n\r\nlocal buff = buffer.create(enumType.size(value))\r\nenumType.ser(buff, 0, value)\r\n\r\nlocal _, deserializedValue = enumType.des(buff, 0)\r\nprint(deserializedValue) --\x3e Enum.Material.Concrete\n"})}),"\n",(0,s.jsx)(r.h2,{id:"bitfield",children:"Bitfield"}),"\n",(0,s.jsx)(r.p,{children:"A bitfield allows you to pack multiple numeric values into a single integer by allocating a specific number of bits for each value. This is useful for efficiently storing small integers with bit precision. The provided type has to be either an unsigned or signed integer, other types might work if they are constant sized but this is the intended use case."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:'--allocated 2, 2, and 4 bits respectively, must add up to the type\'s size\r\nlocal bitfieldType = ByteWorks.bitfield(ByteWorks.u8, {2, 2, 4})\r\n\r\nlocal values = {2, 1, 8}\r\n\r\nlocal buff = buffer.create(bitfieldType.size(values))\r\nbitfieldType.ser(buff, 0, values)\r\n\r\nlocal _, deserializedValues = bitfieldType.des(buff, 0)\r\nprint(table.concat(deserializedValues, ", ")) --\x3e 2, 1, 8\n'})}),"\n",(0,s.jsx)(r.h2,{id:"bitmask",children:"Bitmask"}),"\n",(0,s.jsx)(r.p,{children:"A bitmask allows you to store multiple boolean flags in a single byte (or larger integer, if enough flags are present). Each bit in the byte represents a single flag, making it highly space-efficient."}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-lua",children:"local bitmaskType = ByteWorks.bitmask(8)\r\n\r\n--create a table of boolean flags to serialize\r\nlocal flags = {true, false, true, false, true, false, true, false}\r\n\r\nlocal buff = buffer.create(bitmaskType.size(flags))\r\nbitmaskType.ser(buff, 0, flags)\r\n\r\nlocal _, deserializedFlags = bitmaskType.des(buff, 0)\r\nprint(deserializedFlags) --\x3e {true, false, true, false, true, false, true, false}\n"})})]})}function o(e={}){const{wrapper:r}={...(0,i.R)(),...e.components};return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,r,t)=>{t.d(r,{R:()=>a,x:()=>l});var n=t(6540);const s={},i=n.createContext(s);function a(e){const r=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function l(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),n.createElement(i.Provider,{value:r},e.children)}}}]);