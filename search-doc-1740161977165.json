{"searchDocs":[{"title":"Intro","type":0,"sectionRef":"#","url":"/ByteWorks/docs/intro","content":"","keywords":"","version":"Next"},{"title":"Key Features​","type":1,"pageTitle":"Intro","url":"/ByteWorks/docs/intro#key-features","content":" Flexible: Missing a serializer you need? You can easily implement it yourself and it will work with existing types.Modular and Composable: Compose serializers to handle even the most complex data structures with ease.Bit-Level Precision: Work with bitfields and bitmasks to pack data efficiently and manage binary flags.  ","version":"Next","tagName":"h2"},{"title":"Who Is ByteWorks For?​","type":1,"pageTitle":"Intro","url":"/ByteWorks/docs/intro#who-is-byteworks-for","content":" ByteWorks is for any Roblox developer who needs to work with binary data. Whether you're:  Building a multiplayer game and need to send data over the network efficiently,Saving game state or player data in a compact format, ","version":"Next","tagName":"h2"},{"title":"Advanced Examples","type":0,"sectionRef":"#","url":"/ByteWorks/docs/advanced_examples","content":"","keywords":"","version":"Next"},{"title":"Maps with Literals​","type":1,"pageTitle":"Advanced Examples","url":"/ByteWorks/docs/advanced_examples#maps-with-literals","content":" In this example, the keys of the map only occupy 1 byte since we are using literals as keys. This also means the key can only be &quot;key1&quot;, &quot;key2&quot;, or &quot;key3&quot;, or it will error.  local map = ByteWorks.map( ByteWorks.literal(&quot;key1&quot;, &quot;key2&quot;, &quot;key3&quot;), ByteWorks.f32 ) local data = { key1 = 123, key3 = 567 } local buff = buffer.create(map.size(data)) map.ser(buff, 0, data) local _, deserializedData = map.des(buff, 0) print(deserializedData) --&gt; {key1 = 123, key3 = 567}  ","version":"Next","tagName":"h2"},{"title":"Examples","type":0,"sectionRef":"#","url":"/ByteWorks/docs/examples","content":"","keywords":"","version":"Next"},{"title":"Basic Usage​","type":1,"pageTitle":"Examples","url":"/ByteWorks/docs/examples#basic-usage","content":" ","version":"Next","tagName":"h2"},{"title":"Built-in Functions​","type":1,"pageTitle":"Examples","url":"/ByteWorks/docs/examples#built-in-functions","content":" ByteWorks provides two convenient functions, createAndSerialize and resultExcludingCursor, to simplify serialization and deserialization, at the cost of a minimal performance overhead.  --define a serializer for a vector3 with each axis using a f32 local vector3Type = ByteWorks.vector3(ByteWorks.f32) --create buffer from the serializer type and data local vector = Vector3.new(1, 2, 3) local buff = ByteWorks.createAndSerialize(vector3Type, vector) --extract the data from the buffer local deserializedVector = ByteWorks.resultExcludingCursor(vector3Type, buff, 0) print(deserializedVector) --&gt; 1, 2, 3   ","version":"Next","tagName":"h3"},{"title":"Raw Usage​","type":1,"pageTitle":"Examples","url":"/ByteWorks/docs/examples#raw-usage","content":" For more control and performance, you can use the ser, des, and size methods directly.  local u16Type = ByteWorks.u16 --create a buffer with enough space for that type --for u16, the size is constant so the parameter is optional, however if you use strict then you still want to pass in the value because of how the type works local buff = buffer.create(u16Type.size(42)) --serialize the number u16Type.ser(buff, 0, 42) --deserialize, ignore the first argument that is the cursor local _offset_, value = u16Type.des(buff, 0) print(value) --&gt; 42   ","version":"Next","tagName":"h3"},{"title":"Custom Types​","type":1,"pageTitle":"Examples","url":"/ByteWorks/docs/examples#custom-types","content":" In ByteWorks, you can easily define custom serializers to get specific behavior you need, custom serializers will work with all built in types.  --very very simple example but you can do whatever you can come up with local customType: ByteWorks.ByteWorksType&lt;{number}&gt; = table.freeze({ ser = function(buff, offset, value) buffer.writeu8(buff, offset, value[1]) offset += 1 buffer.writeu8(buff, offset, value[2]) offset += 1 return offset end, des = function(buff, offset) local num1, num2 = buffer.readu8(buff, offset), buffer.readu8(buff, offset + 1) return offset + 2, {num1, num2} --offset gets returned first end, size = function(value) return 2 end, }) local data = {5, 10} local buff = byteWorks.createAndSerialize(customType, data) local deserialized = byteWorks.resultExcludingCursor(customType, buff, 0) print(deserialized) --&gt; {5, 10}   ","version":"Next","tagName":"h2"},{"title":"Merged Buffers​","type":1,"pageTitle":"Examples","url":"/ByteWorks/docs/examples#merged-buffers","content":" local u8Type = ByteWorks.u8 local stringType = ByteWorks.string local vector3Type = ByteWorks.vector3(ByteWorks.f32) --create a buffer with enough space to fit all 3 values local buff = buffer.create( u8Type.size(42) + stringType.size(&quot;Hello&quot;) + vector3Type.size(Vector3.new(1, 2, 3)) ) --serialize sequentially local offset = 0 offset = u8Type.ser(buff, offset, 42) offset = stringType.ser(buff, offset, &quot;Hello&quot;) offset = vector3Type.ser(buff, offset, Vector3.new(1, 2, 3)) --deserialize sequentially offset = 0 --since this example is doing it in the same scope, we need to set offset back to 0 local value1 offset, value1 = u8Type.des(buff, offset) local value2 offset, value2 = stringType.des(buff, offset) local value3 offset, value3 = vector3Type.des(buff, offset) print(value1, value2, value3) --&gt; 42, Hello, 1, 2, 3  ","version":"Next","tagName":"h2"},{"title":"ByteWorks","type":0,"sectionRef":"#","url":"/ByteWorks/api/ByteWorks","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#types","content":" ","version":null,"tagName":"h2"},{"title":"ByteWorksType​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#ByteWorksType","content":"&lt;/&gt; interface ByteWorksType { .ser: ( buff: buffer, offset: number, T... ) → number .des: ( buff: buffer, offset: number ) → ( number, T... ) .size: (T...) → number .optionalFlag: boolean? } A type representing a serialization/deserialization utility for a specific data type. ","version":null,"tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#properties","content":" ","version":null,"tagName":"h2"},{"title":"u8​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#u8","content":"&lt;/&gt; ByteWorks.u8: ByteWorksType&lt;number&gt; Serializes and deserializes an 8-bit unsigned integer.  ","version":null,"tagName":"h3"},{"title":"u16​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#u16","content":"&lt;/&gt; ByteWorks.u16: ByteWorksType&lt;number&gt; Serializes and deserializes a 16-bit unsigned integer.  ","version":null,"tagName":"h3"},{"title":"u24​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#u24","content":"&lt;/&gt; ByteWorks.u24: ByteWorksType&lt;number&gt; Serializes and deserializes a 24-bit unsigned integer.  ","version":null,"tagName":"h3"},{"title":"u32​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#u32","content":"&lt;/&gt; ByteWorks.u32: ByteWorksType&lt;number&gt; Serializes and deserializes a 32-bit unsigned integer.  ","version":null,"tagName":"h3"},{"title":"u53​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#u53","content":"&lt;/&gt; ByteWorks.u53: ByteWorksType&lt;number&gt; Serializes and deserializes a 53-bit unsigned integer.  ","version":null,"tagName":"h3"},{"title":"i8​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#i8","content":"&lt;/&gt; ByteWorks.i8: ByteWorksType&lt;number&gt; Serializes and deserializes an 8-bit signed integer.  ","version":null,"tagName":"h3"},{"title":"i16​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#i16","content":"&lt;/&gt; ByteWorks.i16: ByteWorksType&lt;number&gt; Serializes and deserializes a 16-bit signed integer.  ","version":null,"tagName":"h3"},{"title":"i24​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#i24","content":"&lt;/&gt; ByteWorks.i24: ByteWorksType&lt;number&gt; Serializes and deserializes a 24-bit signed integer.  ","version":null,"tagName":"h3"},{"title":"i32​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#i32","content":"&lt;/&gt; ByteWorks.i32: ByteWorksType&lt;number&gt; Serializes and deserializes a 32-bit signed integer.  ","version":null,"tagName":"h3"},{"title":"i53​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#i53","content":"&lt;/&gt; ByteWorks.i53: ByteWorksType&lt;number&gt; Serializes and deserializes a 53-bit signed integer.  ","version":null,"tagName":"h3"},{"title":"f16​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#f16","content":"&lt;/&gt; ByteWorks.f16: ByteWorksType&lt;number&gt; Serializes and deserializes a 16-bit floating-point number.  ","version":null,"tagName":"h3"},{"title":"f32​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#f32","content":"&lt;/&gt; ByteWorks.f32: ByteWorksType&lt;number&gt; Serializes and deserializes a 32-bit floating-point number.  ","version":null,"tagName":"h3"},{"title":"f64​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#f64","content":"&lt;/&gt; ByteWorks.f64: ByteWorksType&lt;number&gt; Serializes and deserializes a 64-bit floating-point number.  ","version":null,"tagName":"h3"},{"title":"vlq​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#vlq","content":"&lt;/&gt; ByteWorks.vlq: ByteWorksType&lt;number&gt; Serializes and deserializes a variable-length unsigned integer.  ","version":null,"tagName":"h3"},{"title":"svlq​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#svlq","content":"&lt;/&gt; ByteWorks.svlq: ByteWorksType&lt;number&gt; Serializes and deserializes a variable-length signed integer.  ","version":null,"tagName":"h3"},{"title":"string​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#string","content":"&lt;/&gt; ByteWorks.string: ByteWorksType&lt;string&gt; Serializes and deserializes a string.  ","version":null,"tagName":"h3"},{"title":"color3​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#color3","content":"&lt;/&gt; ByteWorks.color3: ByteWorksType&lt;Color3 &gt; Serializes and deserializes a Color3.  ","version":null,"tagName":"h3"},{"title":"cframe​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#cframe","content":"&lt;/&gt; ByteWorks.cframe: ByteWorksType&lt;CFrame &gt; Serializes and deserializes a CFrame.  ","version":null,"tagName":"h3"},{"title":"buffer​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#buffer","content":"&lt;/&gt; ByteWorks.buffer: ByteWorksType&lt;buffer&gt; Serializes and deserializes a buffer.  ","version":null,"tagName":"h3"},{"title":"boolean​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#boolean","content":"&lt;/&gt; ByteWorks.boolean: ByteWorksType&lt;...boolean&gt; Serializes and deserializes a boolean. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#functions","content":" ","version":null,"tagName":"h2"},{"title":"bitmask​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#bitmask","content":"&lt;/&gt; ByteWorks.bitmask(bitCount: number) → ByteWorksType&lt;{boolean}&gt; Creates a bitmask serializer/deserializer.  ","version":null,"tagName":"h3"},{"title":"vector3​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#vector3","content":"&lt;/&gt; ByteWorks.vector3(serDesType: ByteWorksType&lt;number&gt;) → ByteWorksType&lt;Vector3 &gt; Creates a Vector3 serializer/deserializer.  ","version":null,"tagName":"h3"},{"title":"bitfield​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#bitfield","content":"&lt;/&gt; ByteWorks.bitfield( serDesType: ByteWorksType&lt;number&gt;, bitCounts: {number} ) → ByteWorksType&lt;{number}&gt; Creates a bitfield serializer/deserializer.  ","version":null,"tagName":"h3"},{"title":"fixedSizeBuffer​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#fixedSizeBuffer","content":"&lt;/&gt; ByteWorks.fixedSizeBuffer(size: number) → ByteWorksType&lt;buffer&gt; Creates a fixed-size buffer serializer/deserializer.  ","version":null,"tagName":"h3"},{"title":"opt​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#opt","content":"&lt;/&gt; ByteWorks.opt(serDesType: ByteWorksType&lt;T&gt;) → ByteWorksType&lt;T&gt; Wraps a serializer/deserializer to make it optional.  ","version":null,"tagName":"h3"},{"title":"tupleIOToTable​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#tupleIOToTable","content":"&lt;/&gt; ByteWorks.tupleIOToTable(serDesType: ByteWorksType&lt;...any&gt;) → ByteWorksType&lt;any&gt; Converts a tuple-based serializer/deserializer to a table-based one.  ","version":null,"tagName":"h3"},{"title":"tableIOToTuple​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#tableIOToTuple","content":"&lt;/&gt; ByteWorks.tableIOToTuple(serDesType: ByteWorksType&lt;any&gt;) → ByteWorksType&lt;...any&gt; Converts a table-based serializer/deserializer to a tuple-based one.  ","version":null,"tagName":"h3"},{"title":"tuple​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#tuple","content":"&lt;/&gt; ByteWorks.tuple(...: ByteWorksType&lt;any&gt;) → ByteWorksType&lt;...any&gt; Creates a tuple serializer/deserializer.  ","version":null,"tagName":"h3"},{"title":"literal​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#literal","content":"&lt;/&gt; ByteWorks.literal(...: any) → ByteWorksType&lt;any&gt; Creates a serializer/deserializer for a set of literal values.  ","version":null,"tagName":"h3"},{"title":"enum​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#enum","content":"&lt;/&gt; ByteWorks.enum(enum: Enum ) → ByteWorksType&lt;any&gt; Creates a serializer/deserializer for an enum.  ","version":null,"tagName":"h3"},{"title":"array​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#array","content":"&lt;/&gt; ByteWorks.array(serDesType: ByteWorksType&lt;T&gt;) → ByteWorksType&lt;{T}&gt; Creates a serializer/deserializer for an array.  ","version":null,"tagName":"h3"},{"title":"fixedSizeArray​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#fixedSizeArray","content":"&lt;/&gt; ByteWorks.fixedSizeArray( serDesType: ByteWorksType&lt;T&gt;, fixedSize: number ) → ByteWorksType&lt;{T}&gt; Creates a serializer/deserializer for a fixed-size array.  ","version":null,"tagName":"h3"},{"title":"struct​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#struct","content":"&lt;/&gt; ByteWorks.struct(fields: {[string]: ByteWorksType&lt;any&gt;}) → ByteWorksType&lt;{[string]: any}&gt; Creates a serializer/deserializer for a struct.  ","version":null,"tagName":"h3"},{"title":"optStruct​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#optStruct","content":"&lt;/&gt; ByteWorks.optStruct(fields: {[string]: ByteWorksType&lt;any&gt;}) → ByteWorksType&lt;{[string]: any}&gt; Creates a serializer/deserializer for an optional struct.  ","version":null,"tagName":"h3"},{"title":"map​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#map","content":"&lt;/&gt; ByteWorks.map( keyType: ByteWorksType&lt;K&gt;, valueType: ByteWorksType&lt;V&gt; ) → ByteWorksType&lt;{[K]: V}&gt; Creates a serializer/deserializer for a map.  ","version":null,"tagName":"h3"},{"title":"createBufferFromType​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#createBufferFromType","content":"&lt;/&gt; ByteWorks.createBufferFromType( serDesType: ByteWorksType&lt;T&gt;, ...: T ) → buffer Creates a buffer from a serializer/deserializer and values.  ","version":null,"tagName":"h3"},{"title":"resultExcludingCursor​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#resultExcludingCursor","content":"&lt;/&gt; ByteWorks.resultExcludingCursor( serDesType: ByteWorksType&lt;T&gt;, buff: buffer, offset: number ) → ...T Deserializes a value, excluding the cursor.  ","version":null,"tagName":"h3"},{"title":"createAndSerialize​","type":1,"pageTitle":"ByteWorks","url":"/ByteWorks/api/ByteWorks#createAndSerialize","content":"&lt;/&gt; ByteWorks.createAndSerialize( serDesType: ByteWorksType&lt;T&gt;, ...: T ) → buffer Creates a buffer and serializes values into it. ","version":null,"tagName":"h3"},{"title":"Types","type":0,"sectionRef":"#","url":"/ByteWorks/docs/how","content":"","keywords":"","version":"Next"},{"title":"Numbers​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#numbers","content":" Numbers in luau are stored as 8 byte double precision floating point numbers. If we want to represent integers, then the representable range is −2⁵³ to 2⁵³.  ","version":"Next","tagName":"h2"},{"title":"Unsigned Integers​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#unsigned-integers","content":" Unsigned integers refer to whole numbers. The available types with their respective ranges are:  Type\tBytes\tMin\tMaxu8\t1\t0\t255 u16\t2\t0\t65,535 u24\t3\t0\t16,777,215 u32\t4\t0\t4,294,967,295 u53\t7\t0\t9,007,199,254,740,992  ","version":"Next","tagName":"h3"},{"title":"Signed Integers​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#signed-integers","content":" Signed Integers refer to integers as they are commonly known in math. They have a sign bit as their first bit to dictate whether the number is a positive number or a negative number. The available types with their respective ranges are:  Type\tBytes\tMin\tMaxi8\t1\t-128\t127 i16\t2\t-32,768\t32,767 i24\t3\t-8,388,608\t8,388,607 i32\t4\t-2,147,483,648\t2,147,483,647 i53\t7\t-9,007,199,254,740,992\t9,007,199,254,740,992  You are able to store up to 56 bit integers theoretically with i53, but past the specified ranges integers are not exactly representable anymore, since they round to a multiple higher than 1.  ","version":"Next","tagName":"h3"},{"title":"Floating Point Numbers​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#floating-point-numbers","content":" Floating point numbers are commonly known as decimal numbers, the available types are:  Type\tBytes\tMin\tMaxf16\t2\t-65,504\t65,504 f32\t4\tca. -10^38\tca. 10^38 f64\t8\tca. -10^308\tca 10^308  It is very important to note that floating point numbers behave differently from integers, with floating point numbers, the higher the number is, the lower the precision. Let me demonstrate this with f16:  Min\tMax\tInterval128\t256\t0.125 256\t512\t0.25 512\t1024\t0.5 1024\t2048\t1 2048\t4096\t2 4096\t8192\t4  Naturally, f32 and f64 have way better precision with low numbers like these, but this is something you have to keep in mind when using floating point numbers, especially when you're using f16.  ","version":"Next","tagName":"h3"},{"title":"Variable Length Quantity​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#variable-length-quantity","content":" Variable length quantity numbers are useful when you don't know how many bytes a number needs, or when you encode a diverse set of numbers and you don't want to opt for the largest type needed to accomodate every possible number you will serialize. VLQs store the number in the first 7 bits and the last bit is the &quot;continuation bit&quot;, which basically tells the algorithm if there is more to the number and if it should continue reading/writing. This means that VLQs are less efficient if you have numbers in similar ranges, as each block of 8 bits needs a continuation bit.  Here are some example ranges for different byte counts:  Bytes\tMin\tMax1\t0\t127 2\t0\t16,383 3\t0\t2,097,151  ","version":"Next","tagName":"h3"},{"title":"Signed Variable Length Quantity​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#signed-variable-length-quantity","content":" Here are some example ranges for different byte counts:  Bytes\tMin\tMax1\t-63\t63 2\t-8,191\t8,191 3\t-1,048,575\t1,048,575  ","version":"Next","tagName":"h3"},{"title":"Booleans​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#booleans","content":" We only need 1 bit to determine if a boolean is true (1) or false (0), however buffers work in bytes, so we can combine 8 booleans into 1 byte to make the most of our space.  local boolean = ByteWorks.boolean local buff = buffer.create(boolean.size()) boolean.ser(buff, 0, true, true, false, false, true, false, true, false) --we use select because the first returned value is the offset after the deserialization, and we dont need that print(select(2, boolean.des(buff, 0))) --&gt; true true false false true false true false   ","version":"Next","tagName":"h2"},{"title":"Buffers​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#buffers","content":" Buffers can be written into buffers, which is just a copy operation, this is useful if you only want to serialize data when it changes instead of every time it is replicated for example.  local bufferType = ByteWorks.buffer local sourceBuff = buffer.create(4) buffer.writeu32(sourceBuff, 0, 123456) --write some data into the source buffer local destBuff = buffer.create(bufferType.size(sourceBuff)) bufferType.ser(destBuff, 0, sourceBuff) local _, deserializedBuff = bufferType.des(destBuff, 0) print(buffer.readu32(deserializedBuff, 0)) --&gt; 123456   ","version":"Next","tagName":"h2"},{"title":"CFrame​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#cframe","content":" Simple implementation of CFrame serialization and deserialization, it is very general purpose and I reccomend making your own serializer for CFrames that is better suited to your needs.  local cframeType = ByteWorks.cframe local cframe = CFrame.new(10, 20, 30) * CFrame.fromOrientation(math.pi / 4, math.pi / 2, 0) local buff = buffer.create(cframeType.size(cframe)) cframeType.ser(buff, 0, cframe) local _, deserializedCFrame = cframeType.des(buff, 0) print(deserializedCFrame.Position, deserializedCFrame:ToOrientation()) --&gt; 10, 20, 30, pi/4, pi/2, 0   ","version":"Next","tagName":"h2"},{"title":"Arrays​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#arrays","content":" There are both dynamic arrays and fixed size arrays, arrays can only work with one type.  ","version":"Next","tagName":"h2"},{"title":"Dynamic Arrays​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#dynamic-arrays","content":" local arrayType = ByteWorks.array(ByteWorks.u8) local data = {1, 2, 3, 4, 5} local buff = buffer.create(arrayType.size(data)) arrayType.ser(buff, 0, data) local _, deserializedData = arrayType.des(buff, 0) print(table.concat(deserializedData, &quot;, &quot;)) --&gt; 1, 2, 3, 4, 5   ","version":"Next","tagName":"h3"},{"title":"Fixed Size Arrays​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#fixed-size-arrays","content":" local fixedArrayType = ByteWorks.fixedSizeArray(ByteWorks.u8, 3) local data = {10, 20, 30} local buff = buffer.create(fixedArrayType.size(data)) fixedArrayType.ser(buff, 0, data) local _, deserializedData = fixedArrayType.des(buff, 0) print(table.concat(deserializedData, &quot;, &quot;)) --&gt; 10, 20, 30   ","version":"Next","tagName":"h3"},{"title":"Maps​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#maps","content":" Maps are tables that associate keys with values. While the value type can be anything, the key type must be indexable (e.g., numbers, strings).  local mapType = ByteWorks.map(ByteWorks.string, ByteWorks.u8) local data = {apple = 1, banana = 2, cherry = 3} local buff = buffer.create(mapType.size(data)) mapType.ser(buff, 0, data) local _, deserializedData = mapType.des(buff, 0) print(deserializedData) --&gt; {apple = 1, banana = 2, cherry = 3}   ","version":"Next","tagName":"h2"},{"title":"Struct​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#struct","content":" Structs map a string identifier to a specific value type, since the identifiers are known ahead of time, we don't have to serialize them.  ","version":"Next","tagName":"h2"},{"title":"Regular Structs​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#regular-structs","content":" local structType = ByteWorks.struct({ name = ByteWorks.string, age = ByteWorks.u8, isAdmin = ByteWorks.boolean, }) local data = {name = &quot;Alice&quot;, age = 25, isAdmin = true} local buff = buffer.create(structType.size(data)) structType.ser(buff, 0, data) local _, deserializedData = structType.des(buff, 0) print(deserializedData) --&gt; {name = &quot;Alice&quot;, age = 25, isAdmin = true}   ","version":"Next","tagName":"h3"},{"title":"Optional Structs​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#optional-structs","content":" Structs also support optional fields, the cost for an optional field is only 1 byte per 8 optionals. They are a seperate type due to performance implications.  local optStructType = ByteWorks.optStruct({ name = ByteWorks.string, age = ByteWorks.opt(ByteWorks.u8), }) local data = {name = &quot;John&quot;, age = nil} local buff = buffer.create(optStructType.size(data)) optStructType.ser(buff, 0, data) local _, deserializedData = optStructType.des(buff, 0) print(deserializedData) --&gt; {name = &quot;John&quot;}   ","version":"Next","tagName":"h3"},{"title":"Literal​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#literal","content":" Literals are values that can be stored with just an u8, which is useful for things like unique identifiers.  local literalType = ByteWorks.literal(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;) local value = &quot;banana&quot; local buff = buffer.create(literalType.size(value)) literalType.ser(buff, 0, value) local _, deserializedValue = literalType.des(buff, 0) print(deserializedValue) --&gt; banana   ","version":"Next","tagName":"h2"},{"title":"Enum​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#enum","content":" Enums store a roblox Enum either as an u8 or an u16, depending on the highest enum value present within that enum.  local enumType = ByteWorks.enum(Enum.Material) local value = Enum.Material.Concrete local buff = buffer.create(enumType.size(value)) enumType.ser(buff, 0, value) local _, deserializedValue = enumType.des(buff, 0) print(deserializedValue) --&gt; Enum.Material.Concrete   ","version":"Next","tagName":"h2"},{"title":"Bitfield​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#bitfield","content":" A bitfield allows you to pack multiple numeric values into a single integer by allocating a specific number of bits for each value. This is useful for efficiently storing small integers with bit precision. The provided type has to be either an unsigned or signed integer, other types might work if they are constant sized but this is the intended use case.  --allocated 2, 2, and 4 bits respectively, must add up to the type's size local bitfieldType = ByteWorks.bitfield(ByteWorks.u8, {2, 2, 4}) local values = {2, 1, 8} local buff = buffer.create(bitfieldType.size(values)) bitfieldType.ser(buff, 0, values) local _, deserializedValues = bitfieldType.des(buff, 0) print(table.concat(deserializedValues, &quot;, &quot;)) --&gt; 2, 1, 8   ","version":"Next","tagName":"h2"},{"title":"Bitmask​","type":1,"pageTitle":"Types","url":"/ByteWorks/docs/how#bitmask","content":" A bitmask allows you to store multiple boolean flags in a single byte (or larger integer, if enough flags are present). Each bit in the byte represents a single flag, making it highly space-efficient.  local bitmaskType = ByteWorks.bitmask(8) --create a table of boolean flags to serialize local flags = {true, false, true, false, true, false, true, false} local buff = buffer.create(bitmaskType.size(flags)) bitmaskType.ser(buff, 0, flags) local _, deserializedFlags = bitmaskType.des(buff, 0) print(deserializedFlags) --&gt; {true, false, true, false, true, false, true, false}  ","version":"Next","tagName":"h2"}],"options":{"id":"default"}}